<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LIQUID GLASS CHESS - v2.2</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --glass-blur: 15px;
            --glass-opacity: 0.03;
            --glass-bg: rgba(255, 255, 255, var(--glass-opacity));
            --glass-border: rgba(255, 255, 255, 0.1);
            --accent-glow: #00d4ff;
            --danger-glow: #ff0055;
            --dark-bg: #020617;
            --win-bg: rgba(0, 212, 255, 0.95);
            --lose-bg: rgba(255, 0, 85, 0.95);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--dark-bg);
            color: white;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #bg-canvas {
            position: fixed;
            inset: 0;
            z-index: -1;
            filter: blur(80px);
            opacity: 0.6;
        }

        .container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            width: 95%;
            max-width: 600px;
        }

        .glass-header {
            width: 100%;
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border);
            padding: 12px 20px;
            border-radius: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .title-group { display: flex; flex-direction: column; }
        .title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            letter-spacing: 2px;
            color: var(--accent-glow);
        }
        .level-tag { font-size: 0.6rem; opacity: 0.6; text-transform: uppercase; }

        .timer-group {
            display: flex;
            gap: 15px;
            font-family: 'Orbitron', sans-serif;
        }
        .timer {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 60px;
        }
        .time-val { font-size: 1rem; font-weight: 700; }
        .time-label { font-size: 0.5rem; opacity: 0.5; }
        .timer.active { color: var(--accent-glow); text-shadow: 0 0 10px var(--accent-glow); }

        #board-wrapper {
            position: relative;
            width: 100%;
            aspect-ratio: 1/1;
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 8px;
            box-shadow: 0 40px 100px rgba(0,0,0,0.5);
        }

        #board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 100%;
            height: 100%;
        }

        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .square.light { background: rgba(255, 255, 255, 0.02); }
        .square.dark { background: rgba(0, 0, 0, 0.2); }
        .square.selected { background: rgba(0, 212, 255, 0.15) !important; box-shadow: inset 0 0 15px rgba(0, 212, 255, 0.3); }

        .square.hint::after {
            content: '';
            width: 10px;
            height: 10px;
            background: rgba(0, 212, 255, 0.4);
            border-radius: 50%;
        }

        .square.capture-hint::after {
            content: '';
            position: absolute;
            width: 70%;
            height: 70%;
            border: 2px solid rgba(255, 0, 85, 0.4);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .piece {
            font-size: 2.8rem;
            z-index: 5;
            transition: transform 0.25s cubic-bezier(0.19, 1, 0.22, 1);
            filter: drop-shadow(0 5px 10px rgba(0,0,0,0.5));
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }
        
        @media (max-width: 500px) { .piece { font-size: 2rem; } }

        .piece.white { color: #fff; text-shadow: 0 0 10px rgba(255,255,255,0.4); }
        .piece.black { color: #444; text-shadow: 0 0 15px rgba(0,0,0,0.8); }

        .controls {
            display: grid;
            grid-template-columns: 2fr 2fr 1fr 1fr;
            gap: 8px;
            width: 100%;
        }

        .btn {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            color: white;
            padding: 10px;
            border-radius: 12px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            backdrop-filter: blur(var(--glass-blur));
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn:hover {
            transform: translateY(-2px);
            background: rgba(255,255,255,0.1);
            border-color: var(--accent-glow);
            box-shadow: 0 5px 15px rgba(0, 212, 255, 0.2);
        }

        .btn.active { border-color: var(--accent-glow); color: var(--accent-glow); background: rgba(0, 212, 255, 0.05); }

        #settings-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(25px);
            z-index: 200;
            display: none;
            align-items: center;
            justify-content: center;
            overflow-y: auto;
            padding: 20px;
        }

        .settings-panel {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            padding: 30px;
            border-radius: 24px;
            width: 100%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .setting-row { margin-bottom: 24px; display: flex; flex-direction: column; gap: 10px; }
        .setting-label { font-size: 0.7rem; opacity: 0.6; font-family: 'Orbitron', sans-serif; letter-spacing: 1px; }

        input[type="range"] {
            width: 100%;
            accent-color: var(--accent-glow);
            height: 4px;
            cursor: pointer;
        }

        #result-overlay {
            position: absolute;
            inset: 0;
            z-index: 300;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 12px;
            padding: 20px;
            animation: fadeIn 0.5s ease-out;
        }

        .win-state { background: var(--win-bg); color: #fff; }
        .lose-state { background: var(--lose-bg); color: #fff; }

        .result-title { font-family: 'Orbitron', sans-serif; font-size: 2.5rem; font-weight: 900; text-shadow: 0 0 20px rgba(0,0,0,0.5); }
        .result-subtitle { font-size: 1rem; opacity: 0.9; margin-bottom: 30px; letter-spacing: 2px; }

        .grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; }
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }
    </style>
</head>
<body>

    <canvas id="bg-canvas"></canvas>

    <div class="container">
        <header class="glass-header">
            <div class="title-group">
                <div class="title">NEURAL CHESS</div>
                <div id="level-display" class="level-tag">PV CORE (LVL 1)</div>
            </div>
            <div class="timer-group">
                <div id="timer-w" class="timer">
                    <span class="time-val">10:00</span>
                    <span class="time-label">WHITE</span>
                </div>
                <div id="timer-b" class="timer">
                    <span class="time-val">10:00</span>
                    <span class="time-label">BLACK</span>
                </div>
            </div>
        </header>

        <div id="board-wrapper">
            <div id="board"></div>
            <div id="result-overlay">
                <div class="result-title" id="res-title">VICTORY</div>
                <div class="result-subtitle" id="res-sub">CORE SHUTDOWN SUCCESSFUL</div>
                <button class="btn" style="background: #fff; color: #000; width: 100%;" onclick="initGame()">REBOOT INTERFACE</button>
            </div>
        </div>

        <div class="controls">
            <button id="mode-pvp" class="btn active" onclick="setMode('pvp')">PVP</button>
            <button id="mode-pvc" class="btn" onclick="setMode('pvc')">CORE</button>
            <button class="btn" onclick="openSettings()">SETTINGS</button>
            <button class="btn" onclick="undoMove()">↺</button>
        </div>
    </div>

    <div id="settings-overlay" onclick="closeSettings(event)">
        <div class="settings-panel" onclick="event.stopPropagation()">
            <h2 style="font-family: 'Orbitron', sans-serif; margin-bottom: 25px; font-size: 1.2rem;">SYSTEM CONFIG</h2>
            
            <div class="setting-row">
                <label class="setting-label">CORE INTELLIGENCE</label>
                <div class="grid-3">
                    <button class="btn lvl-btn" onclick="setDifficulty(1)">BASIC</button>
                    <button class="btn lvl-btn" onclick="setDifficulty(2)">PRO</button>
                    <button class="btn lvl-btn" onclick="setDifficulty(3)">ELITE</button>
                    <button class="btn lvl-btn" onclick="setDifficulty(4)">MASTER</button>
                    <button class="btn lvl-btn" onclick="setDifficulty(5)">GOD</button>
                </div>
            </div>

            <div class="setting-row">
                <label class="setting-label">TEMPORAL LIMIT</label>
                <div class="grid-3">
                    <button class="btn time-btn" onclick="setClock(1)">1M</button>
                    <button class="btn time-btn" onclick="setClock(3)">3M</button>
                    <button class="btn time-btn" onclick="setClock(5)">5M</button>
                    <button class="btn time-btn" onclick="setClock(10)">10M</button>
                    <button class="btn time-btn" onclick="setClock(30)">30M</button>
                </div>
            </div>

            <div class="setting-row">
                <label class="setting-label">AUDIO FEEDBACK</label>
                <div class="grid-2">
                    <button id="audio-on" class="btn audio-toggle" onclick="setAudio(true)">ENABLED</button>
                    <button id="audio-off" class="btn audio-toggle" onclick="setAudio(false)">MUTED</button>
                </div>
            </div>

            <div class="setting-row">
                <label class="setting-label">GLASS INTENSITY</label>
                <input type="range" id="intensity-slider" min="5" max="40" value="15" oninput="updateIntensity(this.value)">
            </div>

            <div class="setting-row">
                <label class="setting-label">BACKGROUND FLUIDITY</label>
                <div class="grid-3">
                    <button class="btn bg-btn" onclick="setBgTemplate('default')">DEFAULT</button>
                    <button class="btn bg-btn" onclick="setBgTemplate('supernova')">SUPERNOVA</button>
                    <button class="btn bg-btn" onclick="setBgTemplate('deepsea')">DEEP SEA</button>
                    <button class="btn bg-btn" onclick="setBgTemplate('nebula')">NEBULA</button>
                    <button class="btn bg-btn" onclick="setBgTemplate('matrix')">MATRIX</button>
                </div>
            </div>

            <button class="btn" style="width: 100%; margin-top: 20px; background: var(--accent-glow); color: #000;" onclick="closeSettings()">SAVE & SYNC</button>
        </div>
    </div>

<script>
    // --- Audio Engine ---
    const AudioEngine = {
        ctx: null,
        enabled: true,
        init() {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        },
        play(freq, type, dur, vol = 0.1) {
            if (!this.enabled || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            gain.gain.setValueAtTime(vol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + dur);
        },
        move() { this.play(400, 'sine', 0.1, 0.05); },
        capture() { this.play(200, 'square', 0.2, 0.05); },
        check() { this.play(800, 'triangle', 0.3, 0.1); },
        win() { 
            this.play(523, 'sine', 0.5, 0.1); 
            setTimeout(() => this.play(659, 'sine', 0.5, 0.1), 100);
            setTimeout(() => this.play(783, 'sine', 0.5, 0.1), 200);
        },
        lose() {
            this.play(300, 'sawtooth', 0.5, 0.1);
            setTimeout(() => this.play(250, 'sawtooth', 0.5, 0.1), 200);
        }
    };

    // --- Initial State ---
    const PIECES = {
        w: { k: '♔', q: '♕', r: '♖', b: '♗', n: '♘', p: '♙' },
        b: { k: '♚', q: '♛', r: '♜', b: '♝', n: '♞', p: '♟' }
    };

    let board = [];
    let selectedSquare = null;
    let turn = 'w';
    let gameMode = 'pvp';
    let history = [];
    let timerInterval = null;

    // --- Persistent Settings ---
    let config = {
        difficulty: 1,
        intensity: 15,
        bgTemplate: 'default',
        clock: 10,
        audio: true
    };

    let timers = { w: 600, b: 600 };

    function loadSettings() {
        const saved = localStorage.getItem('neural_chess_v2_2_settings');
        if (saved) config = JSON.parse(saved);
        updateIntensity(config.intensity);
        AudioEngine.enabled = config.audio;
        applySettingsUI();
    }

    function saveSettings() {
        localStorage.setItem('neural_chess_v2_2_settings', JSON.stringify(config));
    }

    function applySettingsUI() {
        document.getElementById('intensity-slider').value = config.intensity;
        document.querySelectorAll('.lvl-btn').forEach((b, i) => b.classList.toggle('active', i+1 === config.difficulty));
        document.querySelectorAll('.time-btn').forEach(b => b.classList.toggle('active', b.innerText.includes(config.clock + 'M')));
        document.querySelectorAll('.bg-btn').forEach(b => b.classList.toggle('active', b.innerText.toLowerCase().replace(" ", "") === config.bgTemplate));
        document.getElementById('audio-on').classList.toggle('active', config.audio);
        document.getElementById('audio-off').classList.toggle('active', !config.audio);
    }

    // --- Core Gameplay ---
    function initGame() {
        if (!AudioEngine.ctx) AudioEngine.init();
        board = [
            ['br','bn','bb','bq','bk','bb','bn','br'],
            ['bp','bp','bp','bp','bp','bp','bp','bp'],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            ['wp','wp','wp','wp','wp','wp','wp','wp'],
            ['wr','wn','wb','wq','wk','wb','wn','wr']
        ];
        turn = 'w';
        selectedSquare = null;
        history = [];
        timers = { w: config.clock * 60, b: config.clock * 60 };
        document.getElementById('result-overlay').style.display = 'none';
        
        clearInterval(timerInterval);
        startTimer();
        render();
    }

    function render() {
        const boardEl = document.getElementById('board');
        boardEl.innerHTML = '';
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const sq = document.createElement('div');
                sq.className = `square ${(r + c) % 2 === 0 ? 'light' : 'dark'}`;
                const piece = board[r][c];
                if (piece) {
                    const span = document.createElement('span');
                    span.className = `piece ${piece[0] === 'w' ? 'white' : 'black'}`;
                    span.innerText = PIECES[piece[0]][piece[1]];
                    sq.appendChild(span);
                }
                sq.onclick = () => onSquareClick(r, c);
                boardEl.appendChild(sq);
            }
        }
        updateStatus();
    }

    function onSquareClick(r, c) {
        if (gameMode === 'pvc' && turn === 'b') return;
        const piece = board[r][c];
        
        if (selectedSquare) {
            const moves = getValidMoves(selectedSquare.r, selectedSquare.c);
            const move = moves.find(m => m.r === r && m.c === c);
            if (move) { executeMove(selectedSquare.r, selectedSquare.c, r, c); return; }
        }

        if (piece && piece[0] === turn) {
            selectedSquare = { r, c };
            highlightSquares(r, c);
        } else {
            selectedSquare = null;
            clearHighlights();
        }
    }

    function executeMove(fr, fc, tr, tc) {
        history.push(JSON.parse(JSON.stringify(board)));
        const piece = board[fr][fc];
        const isCapture = !!board[tr][tc];
        
        board[tr][tc] = piece;
        board[fr][fc] = null;
        
        if (piece[1] === 'p' && (tr === 0 || tr === 7)) board[tr][tc] = piece[0] + 'q';

        if (isCapture) AudioEngine.capture(); else AudioEngine.move();

        selectedSquare = null;
        turn = turn === 'w' ? 'b' : 'w';
        render();

        if (gameMode === 'pvc' && turn === 'b') {
            setTimeout(makeCPUMove, 400 + Math.random() * 400);
        }
    }

    // --- Advanced AI Intelligence ---
    function makeCPUMove() {
        let allMoves = [];
        for (let r=0; r<8; r++) {
            for (let c=0; c<8; c++) {
                if (board[r][c] && board[r][c][0] === 'b') {
                    getValidMoves(r, c).forEach(m => {
                        allMoves.push({ 
                            from: {r,c}, 
                            to: m, 
                            score: evaluateMove(r, c, m.r, m.c, config.difficulty) 
                        });
                    });
                }
            }
        }
        if (allMoves.length === 0) return;
        allMoves.sort((a, b) => b.score - a.score);
        
        let chosen;
        const lvl = config.difficulty;
        if (lvl === 1) chosen = allMoves[Math.floor(Math.random() * Math.min(allMoves.length, 5))];
        else if (lvl === 2) chosen = allMoves[Math.floor(Math.random() * Math.min(allMoves.length, 2))];
        else chosen = allMoves[0]; // Elite+ always takes best

        executeMove(chosen.from.r, chosen.from.c, chosen.to.r, chosen.to.c);
    }

    function evaluateMove(fr, fc, tr, tc, lvl) {
        const target = board[tr][tc];
        const vals = { p: 10, n: 30, b: 35, r: 50, q: 90, k: 1000 };
        let s = target ? vals[target[1]] * 10 : 0;
        
        const piece = board[fr][fc][1];
        
        // Center control (D4, D5, E4, E5)
        if (lvl >= 3) {
            const distToCenter = Math.abs(3.5 - tr) + Math.abs(3.5 - tc);
            s += (7 - distToCenter) * 2;
        }

        // Development
        if (lvl >= 4) {
            if (piece === 'p') s += (tr * 1.5);
            if (['n', 'b'].includes(piece) && fr < 2) s += 10; // Develop pieces
        }

        // God Mode Aggression
        if (lvl === 5) {
            if (target && target[1] === 'q') s += 150;
            // Discourage moving king early
            if (piece === 'k' && fr === 0) s -= 50;
        }

        return s + (Math.random() * 2); // Tiny noise
    }

    // --- UI & Controls ---
    function updateIntensity(val) {
        config.intensity = parseInt(val);
        document.documentElement.style.setProperty('--glass-blur', `${val}px`);
        document.documentElement.style.setProperty('--glass-opacity', `${val / 500}`);
        saveSettings();
    }

    function setAudio(on) {
        config.audio = on;
        AudioEngine.enabled = on;
        if (on && !AudioEngine.ctx) AudioEngine.init();
        applySettingsUI();
        saveSettings();
    }

    function setBgTemplate(name) {
        config.bgTemplate = name;
        applySettingsUI();
        saveSettings();
    }

    function setDifficulty(lvl) {
        config.difficulty = lvl;
        applySettingsUI();
        saveSettings();
        initGame();
    }

    function setClock(mins) {
        config.clock = mins;
        applySettingsUI();
        saveSettings();
        initGame();
    }

    function setMode(mode) {
        gameMode = mode;
        document.getElementById('mode-pvp').classList.toggle('active', mode === 'pvp');
        document.getElementById('mode-pvc').classList.toggle('active', mode === 'pvc');
        initGame();
    }

    function startTimer() {
        timerInterval = setInterval(() => {
            timers[turn]--;
            const f = (s) => `${Math.floor(s/60)}:${(s%60).toString().padStart(2,'0')}`;
            document.querySelector('#timer-w .time-val').innerText = f(timers.w);
            document.querySelector('#timer-b .time-val').innerText = f(timers.b);
            document.getElementById('timer-w').classList.toggle('active', turn === 'w');
            document.getElementById('timer-b').classList.toggle('active', turn === 'b');
            if (timers[turn] <= 0) endGame(turn === 'w' ? 'b' : 'w', "TEMPORAL DEPLETION");
        }, 1000);
    }

    function endGame(winner, reason) {
        clearInterval(timerInterval);
        const overlay = document.getElementById('result-overlay');
        overlay.style.display = 'flex';
        overlay.className = winner === 'w' ? 'win-state' : 'lose-state';
        document.getElementById('res-title').innerText = winner === 'w' ? 'VICTORY' : 'DEFEAT';
        document.getElementById('res-sub').innerText = reason;
        
        if (winner === 'w') AudioEngine.win(); else AudioEngine.lose();
    }

    function updateStatus() {
        document.getElementById('level-display').innerText = gameMode === 'pvc' ? `CORE (LVL ${config.difficulty})` : 'PVP MODE';
        let k = {w:0, b:0};
        board.forEach(r => r.forEach(p => { if(p && p[1]==='k') k[p[0]]++; }));
        if (!k.w) endGame('b', 'CORE BREACH: KING LOST');
        if (!k.b) endGame('w', 'VIRUS PURGED: KING CAPTURED');
    }

    // --- Helpers ---
    function getValidMoves(r, c) {
        const piece = board[r][c];
        if (!piece) return [];
        const moves = [];
        const color = piece[0];
        const type = piece[1];

        const pushIf = (nr, nc) => {
            if (nr<0||nr>7||nc<0||nc>7) return false;
            if (!board[nr][nc]) { moves.push({r:nr, c:nc}); return true; }
            if (board[nr][nc][0] !== color) { moves.push({r:nr, c:nc}); return false; }
            return false;
        };

        if (type === 'p') {
            const d = color === 'w' ? -1 : 1;
            if (!board[r+d]?.[c]) {
                moves.push({r:r+d, c});
                if (((color==='w'&&r===6)||(color==='b'&&r===1)) && !board[r+2*d][c]) moves.push({r:r+2*d, c});
            }
            [[-1,1],[1,1]].forEach(o => {
                const tr = r+d, tc = c+o[0];
                if (board[tr]?.[tc] && board[tr][tc][0] !== color) moves.push({r:tr, c:tc});
            });
        } else if (type === 'n') {
            [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]].forEach(o => pushIf(r+o[0], c+o[1]));
        } else if (type === 'k') {
            for(let i=-1;i<=1;i++) for(let j=-1;j<=1;j++) if(i!==0||j!==0) pushIf(r+i, c+j);
        } else if (['r','q'].includes(type)) {
            [[1,0],[-1,0],[0,1],[0,-1]].forEach(d => { for(let i=1;i<8;i++) if(!pushIf(r+d[0]*i, c+d[1]*i)) break; });
        }
        if (['b','q'].includes(type)) {
            [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(d => { for(let i=1;i<8;i++) if(!pushIf(r+d[0]*i, c+d[1]*i)) break; });
        }
        return moves;
    }

    function clearHighlights() { document.querySelectorAll('.square').forEach(s => s.classList.remove('selected', 'hint', 'capture-hint')); }
    function highlightSquares(r, c) {
        clearHighlights();
        const sqs = document.querySelectorAll('.square');
        sqs[r*8+c].classList.add('selected');
        getValidMoves(r, c).forEach(m => sqs[m.r*8+m.c].classList.add(board[m.r][m.c] ? 'capture-hint' : 'hint'));
    }

    function undoMove() {
        if (history.length > 0) {
            board = history.pop();
            turn = turn === 'w' ? 'b' : 'w';
            if (gameMode === 'pvc' && turn === 'b') { board = history.pop() || board; turn = 'w'; }
            render();
        }
    }

    function openSettings() { document.getElementById('settings-overlay').style.display = 'flex'; }
    function closeSettings() { document.getElementById('settings-overlay').style.display = 'none'; }

    // --- Visual Background Engine ---
    const bgCanvas = document.getElementById('bg-canvas');
    const bgCtx = bgCanvas.getContext('2d');
    function animateBG() {
        bgCanvas.width = window.innerWidth;
        bgCanvas.height = window.innerHeight;
        bgCtx.fillStyle = '#020617';
        bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
        
        const time = Date.now();
        let palette = ['#00d4ff', '#0078d4', '#4400ff'];
        let speed = 0.0005;
        let count = 3;

        switch(config.bgTemplate) {
            case 'supernova': palette = ['#ff0055', '#ffaa00', '#ff00ff']; speed = 0.001; count = 4; break;
            case 'deepsea': palette = ['#001133', '#0044ff', '#00ffff']; speed = 0.0002; break;
            case 'nebula': palette = ['#9d00ff', '#00ffcc', '#ff009d']; speed = 0.0004; count = 5; break;
            case 'matrix': palette = ['#00ff41', '#003b00', '#008f11']; speed = 0.0008; count = 2; break;
        }

        palette.forEach((c, i) => {
            for(let j=0; j<Math.floor(count/palette.length) + 1; j++) {
                const shift = i + j * 2;
                const x = bgCanvas.width/2 + Math.cos(time * speed + shift) * (bgCanvas.width/3);
                const y = bgCanvas.height/2 + Math.sin(time * speed * 0.7 + shift) * (bgCanvas.height/3);
                bgCtx.fillStyle = c;
                bgCtx.beginPath();
                bgCtx.arc(x, y, 400, 0, Math.PI*2);
                bgCtx.fill();
            }
        });
        requestAnimationFrame(animateBG);
    }

    window.onload = () => { loadSettings(); initGame(); animateBG(); };
</script>
</body>
</html>